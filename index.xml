<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Visual Computing</title><link>https://dsramirezc.github.io/vc/</link><description>Recent content in Introduction on Visual Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dsramirezc.github.io/vc/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>https://dsramirezc.github.io/vc/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://dsramirezc.github.io/vc/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://dsramirezc.github.io/vc/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://dsramirezc.github.io/vc/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion1/</guid><description>Ilusión Óptica de Hermann o ilusión de cuadrícula # Una ilusión de cuadrícula es cualquier tipo de rejilla que engaña la visión de una persona. Las dos ilusiones más frecuentes son la rejilla de Hermann y la rejilla centellante.
new p5((p5) = { const squares = 10; const size = 500; const dxy=size/squares; const dy=dxy*0.2; const radio=dy/2; p5.setup = function() { p5.createCanvas(size, size); }; p5.draw = function() { p5.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion2/</guid><description>Ilusión Cognitiva de Percepción de Profundidad # Ésta ilusión fué inspirada por éste vídeo
Las ilusiones cognitivas surgen por la interacción con supuestos sobre el mundo, lo que lleva a &amp;ldquo;inferencias inconscientes&amp;rdquo;, una idea sugerida por primera vez en el siglo XIX por el físico y médico alemán Hermann Helmholtz.
Las ilusiones pueden basarse en la capacidad de un individuo para ver en tres dimensiones, aunque la imagen que llega a la retina es solo bidimensional.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/Ilusiones/ilusion3/</guid><description>Ilusión Optica de Sesgo en los puntos de intersección o Ilusión de Zöllner # Hay un gran grupo de ilusiones en las que las líneas que se cruzan en ángulos, particularmente los ángulos agudos, son un factor decisivo en la ilusión. Wundt (1898) llamó la atención sobre esto; los ángulos agudos están sobreestimados y los ángulos obtusos están levemente subestimados.
let angle=80 function setup() { angleMode(DEGREES); less = createButton(&amp;#34;Change Angle&amp;#34;); less.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/Rendering/algoritmo_warnock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/Rendering/algoritmo_warnock/</guid><description>Algoritmo de Warnok # El algoritmo de warnock hace parte de los algoritmos de visibilidad y su enfoque esta en renderizar la imagen, dado que tambien existen metodos de ray-tracing. Este algoritmo pertenece a los HSR (Hidden surface removal algorithms), de los cuales buscan pintar imagenes que solo nos permiten ver lo visible sin importar si están entrecruzadas o superpuestas los objetos geométricos que se encuentran en ella. Existen otra variedad de algoritmos como, el algoritmo del pintor, BSP (Binary Space Partitioning), el Z-buffer, el ray-tracing para superficies poliédricas y cuádricas, algoritmo watkins o conocido como el barrido incremental.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/Rendering/rasterizing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/Rendering/rasterizing/</guid><description>Rasterización de Circunferencias # Para la rasterización de una circunferencia podemos calcular los puntos que van a hacer parte del borde en un único octante y simultaneamente añadir de forma análoga los puntos de los otros octantes, en la animación aquí presentada el único octante que se calcula de forma directa es el de color verde y los demás son añadidos en base a dicho cálculo.
El proceso comienza en el punto P=(0,r), a partir de allí en cada iteración se va calculando el punto correspondiente al octante verde si se aumenta la coordenada x, Dado que al aumentar x en uno (++P.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/avg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/avg/</guid><description>Fotomosaico media # Este mosaico esta basado en https://visualcomputing.github.io/docs/shaders/photomosaic/ para realizar el mosiaco necesitamos de un video o una imagen y un banco de imagenes al cual vamos a mapear las divisiones de la imagen original para hacer el fotomosaico, estas imagenes se ordenan segun el criterio de luminancia es te criterio se implemento tantó en el codigo de javascript como en el fragrment shader.
Criterio de media # 0.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/luma/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/luma/</guid><description>Fotomosaico luminancia # Este mosaico esta basado en https://visualcomputing.github.io/docs/shaders/photomosaic/ para realizar el mosiaco necesitamos de un video o una imagen y un banco de imagenes al cual vamos a mapear las divisiones de la imagen original para hacer el fotomosaico, estas imagenes se ordenan segun el criterio de luminancia es te criterio se implemento tantó en el codigo de javascript como en el fragrment shader.
Criterio de luminancia # 0.</description></item><item><title/><link>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/spatialCoherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dsramirezc.github.io/vc/docs/shortcodes/shaders/spatialCoherence/</guid><description>Fotomosaico coherencia espacial # Este mosaico esta basado en https://visualcomputing.github.io/docs/shaders/spatial_coherence/ para realizar el mosiaco necesitamos de un video o una imagen y otra imagen que sea la representacion del om, que va a ser el caracter con el cual vamos a realizar el mosaico si esta activada esta opción, cada sub parte de la imagen original al ser dividida nos dará una region de la imagen original que usaremos para mapear la nueva zona perteneciente al fotomosaico, con una nueva textura que se acoplé al color de la subparte analizada.</description></item></channel></rss>